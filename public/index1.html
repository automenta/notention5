<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nostr Chat</title>
    <link rel="manifest" href="data:application/manifest+json,{}">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: sans-serif;
        }

        :root {
            --bg: #1a1d21;
            --sidebar-bg: #25292e;
            --header-bg: #1e2227;
            --border: #343a40;
            --text: #e9ecef;
            --text-secondary: #adb5bd;
            --primary: #4dabf7;
            --primary-hover: #339af0;
            --danger: #fa5252;
            --danger-hover: #e03131;
            --success: #20c997;
            --unread-badge: #fa5252;
            --input-bg: #2d333b;
            --message-bg: #2d333b;
            --self-message: #36404a;
            --system-message: #343a40;
            --hover-bg: #343a40;
            --active-bg: #3d444d;
        }

        body {
            background: var(--bg);
            color: var(--text);
            height: 100vh;
            display: flex;
            overflow: hidden;
        }

        #app {
            display: flex;
            width: 100%;
            height: 100%;
        }

        #sidebar {
            width: 280px;
            background: var(--sidebar-bg);
            display: flex;
            flex-direction: column;
            border-right: 1px solid var(--border);
        }

        #identity {
            padding: 16px;
            background: var(--header-bg);
            border-bottom: 1px solid var(--border);
        }

        .user-info {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: var(--primary);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            object-fit: cover;
        }

        .user-details {
            flex: 1;
            min-width: 0;
        }

        .user-name {
            font-weight: 600;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .pubkey {
            font-size: 12px;
            color: var(--text-secondary);
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .action-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 12px;
        }

        button {
            background: var(--primary);
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
            transition: background 0.2s;
            font-size: 13px;
        }

        button:hover {
            background: var(--primary-hover);
        }

        button:disabled {
            background: var(--border);
            cursor: not-allowed;
        }

        button.secondary {
            background: var(--input-bg);
            border: 1px solid var(--border);
        }

        button.secondary:hover:not(:disabled) {
            background: var(--hover-bg);
        }

        #channels {
            overflow-y: auto;
            flex: 1;
            padding: 8px 0;
        }

        .channel {
            padding: 12px 16px;
            display: flex;
            align-items: center;
            cursor: pointer;
            transition: background 0.2s;
            border-radius: 4px;
            margin: 4px 8px;
        }

        .channel:hover {
            background: var(--hover-bg);
        }

        .channel.active {
            background: var(--active-bg);
        }

        .channel-icon {
            margin-right: 12px;
            font-size: 18px;
        }

        .channel-details {
            flex: 1;
            min-width: 0;
        }

        .channel-name {
            display: flex;
            align-items: center;
            gap: 6px;
            font-weight: 500;
        }

        .channel-name span:first-child {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .channel-unread {
            background: var(--unread-badge);
            color: white;
            font-size: 11px;
            padding: 2px 6px;
            border-radius: 10px;
            font-weight: bold;
        }

        .channel-meta {
            font-size: 12px;
            color: var(--text-secondary);
            margin-top: 4px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        #main {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        #chat-header {
            padding: 16px;
            background: var(--header-bg);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        #chat-header .channel-name {
            font-size: 18px;
            font-weight: 600;
        }

        #chat-header-actions {
            display: flex;
            gap: 8px;
        }

        #leave-channel-action-btn {
            background-color: var(--danger);
            border-color: transparent;
        }

        #leave-channel-action-btn:hover:not(:disabled) {
            background-color: var(--danger-hover);
        }

        #chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .message {
            display: flex;
            gap: 10px;
            max-width: 85%;
            align-self: flex-start;
        }

        .message.self {
            align-self: flex-end;
            flex-direction: row-reverse;
        }

        .message.self .message-content {
            background: var(--self-message);
        }

        .message.system {
            align-self: center;
            max-width: 100%;
        }

        .message.system .message-content {
            background: var(--system-message);
            color: var(--text-secondary);
            font-size: 13px;
            padding: 8px 12px;
        }

        .message-avatar .avatar {
            width: 36px;
            height: 36px;
            font-size: 16px;
        }

        .message-content {
            background: var(--message-bg);
            padding: 10px 14px;
            border-radius: 12px;
        }

        .message.self .message-content {
            border-bottom-right-radius: 2px;
        }

        .message:not(.self):not(.system) .message-content {
            border-bottom-left-radius: 2px;
        }

        .message-header {
            display: flex;
            justify-content: space-between;
            align-items: baseline;
            margin-bottom: 4px;
        }

        .message-sender {
            font-weight: 600;
            font-size: 14px;
            color: var(--primary);
        }

        .message.self .message-sender {
            color: var(--primary-hover);
        }

        .message-time {
            font-size: 11px;
            color: var(--text-secondary);
        }

        .message-text {
            line-height: 1.5;
            word-break: break-word;
            white-space: pre-wrap;
        }

        #chat-input {
            padding: 16px;
            background: var(--header-bg);
            border-top: 1px solid var(--border);
        }

        #message-form {
            display: flex;
            gap: 8px;
        }

        #message-input {
            flex: 1;
            background: var(--input-bg);
            border: 1px solid var(--border);
            border-radius: 20px;
            padding: 12px 16px;
            color: var(--text);
            resize: none;
            height: 44px;
            outline: none;
            font-size: 14px;
        }

        #message-input:focus {
            border-color: var(--primary);
        }

        .toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            padding: 12px 24px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 1000;
            transition: opacity 0.3s;
        }

        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        .modal-content {
            background: var(--sidebar-bg);
            padding: 24px;
            border-radius: 8px;
            width: 90%;
            max-width: 400px;
        }

        .modal-content h3 {
            margin-bottom: 16px;
        }

        .modal-content label {
            display: block;
            margin-bottom: 6px;
            font-size: 14px;
        }

        .modal-content input[type="text"], .modal-content input[type="password"] {
            width: 100%;
            background: var(--input-bg);
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: 10px;
            color: var(--text);
            margin-bottom: 16px;
        }

        .modal-buttons {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }

        .hidden {
            display: none !important;
        }

        #loading-indicator {
            position: fixed;
            top: 10px;
            right: 10px;
            background: var(--primary);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            z-index: 3000;
            display: none;
        }
    </style>
</head>
<body>
<div id="app">
    <div id="sidebar">
        <div id="identity">
            <div class="user-info">
                <img class="avatar" id="user-avatar"
                     src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Ctext x='50%25' y='50%25' font-size='50' dominant-baseline='central' text-anchor='middle' fill='white'%3EU%3C/text%3E%3C/svg%3E"
                     alt="User Avatar">
                <div class="user-details">
                    <div id="user-name" class="user-name">Anonymous</div>
                    <div class="pubkey" id="user-pubkey">No identity loaded</div>
                </div>
            </div>
            <div class="action-buttons">
                <button id="identity-action">Load/Create Identity</button>
                <button id="edit-profile-btn" class="secondary" disabled>Edit Profile</button>
                <button id="create-group-btn" class="secondary" disabled>New Group</button>
                <button id="join-group-btn" class="secondary" disabled>Join Group</button>
                <button id="create-dm-btn" class="secondary" disabled>New DM</button>
            </div>
        </div>
        <div id="channels"></div>
    </div>
    <div id="main">
        <div id="chat-header">
            <div class="channel-name">Select a channel</div>
            <div id="chat-header-actions">
                <button id="group-info-action-btn" class="secondary hidden">Group Info</button>
                <button id="leave-channel-action-btn" class="secondary hidden">Leave</button>
            </div>
        </div>
        <div id="chat-messages"></div>
        <div id="chat-input" class="hidden">
            <form id="message-form">
                <textarea id="message-input" placeholder="Type your message..." autocomplete="off"></textarea>
                <button type="submit">Send</button>
            </form>
        </div>
    </div>
</div>
<div id="loading-indicator">Loading...</div>

<div id="identity-modal" class="modal hidden">
    <div class="modal-content">
        <h3>Manage Identity</h3>
        <label for="privkey-input">Enter Secret Key (nsec or hex) or leave blank to generate new:</label>
        <input type="password" id="privkey-input">
        <div class="modal-buttons">
            <button id="identity-modal-cancel">Cancel</button>
            <button id="identity-modal-save">Load / Generate</button>
        </div>
    </div>
</div>

<div id="profile-modal" class="modal hidden">
    <div class="modal-content">
        <h3>Edit Profile</h3>
        <label for="profile-name-input">Display Name:</label>
        <input type="text" id="profile-name-input" placeholder="Satoshi">
        <label for="profile-picture-input">Picture URL:</label>
        <input type="text" id="profile-picture-input" placeholder="https://example.com/avatar.jpg">
        <label for="profile-nip05-input">NIP-05 Identifier:</label>
        <input type="text" id="profile-nip05-input" placeholder="user@domain.com">
        <div class="modal-buttons">
            <button id="profile-modal-cancel">Cancel</button>
            <button id="profile-modal-save">Save</button>
        </div>
    </div>
</div>

<div id="create-group-modal" class="modal hidden">
    <div class="modal-content">
        <h3>Create Encrypted Group</h3>
        <label for="group-name-input">Group Name:</label>
        <input type="text" id="group-name-input">
        <div class="modal-buttons">
            <button id="create-group-modal-cancel">Cancel</button>
            <button id="create-group-modal-create">Create</button>
        </div>
    </div>
</div>

<div id="join-group-modal" class="modal hidden">
    <div class="modal-content">
        <h3>Join Encrypted Group</h3>
        <label for="join-group-id-input">Group ID:</label>
        <input type="text" id="join-group-id-input">
        <label for="join-group-key-input">Group Secret Key (Base64):</label>
        <input type="text" id="join-group-key-input">
        <label for="join-group-name-input">Group Name (for display):</label>
        <input type="text" id="join-group-name-input">
        <div class="modal-buttons">
            <button id="join-group-modal-cancel">Cancel</button>
            <button id="join-group-modal-join">Join</button>
        </div>
    </div>
</div>

<div id="create-dm-modal" class="modal hidden">
    <div class="modal-content">
        <h3>Start Direct Message</h3>
        <label for="dm-pubkey-input">Recipient's Public Key (npub or hex):</label>
        <input type="text" id="dm-pubkey-input">
        <div class="modal-buttons">
            <button id="create-dm-modal-cancel">Cancel</button>
            <button id="create-dm-modal-start">Start DM</button>
        </div>
    </div>
</div>

<div id="group-info-modal" class="modal hidden">
    <div class="modal-content">
        <h3 id="group-info-name">Group Info</h3>
        <p>Share these details with users you want to invite:</p>
        <label>Group ID:</label>
        <input type="text" id="group-info-id" readonly>
        <label>Secret Key (Base64):</label>
        <input type="text" id="group-info-key" readonly>
        <div class="modal-buttons">
            <button id="group-info-close">Close</button>
        </div>
    </div>
</div>

<script src="https://unpkg.com/nostr-tools@latest/lib/nostr.bundle.js"></script>
<script>
    const {generateSecretKey, getPublicKey, finalizeEvent, nip19, nip04, SimplePool} = NostrTools;

    const IdbKeyVal = {
        _db: null,
        _getDb() {
            if (!this._db) {
                this._db = new Promise((resolve, reject) => {
                    const request = indexedDB.open('nostr-chat-db-v2', 1);
                    request.onupgradeneeded = () => request.result.createObjectStore('keyval');
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(request.error);
                });
            }
            return this._db;
        },
        async _withStore(type, callback) {
            const db = await this._getDb();
            return new Promise((resolve, reject) => {
                const transaction = db.transaction('keyval', type);
                transaction.oncomplete = () => resolve();
                transaction.onerror = () => reject(transaction.error);
                callback(transaction.objectStore('keyval'));
            });
        },
        async get(key) {
            let req;
            await this._withStore('readonly', store => {
                req = store.get(key);
            });
            return new Promise((resolve, reject) => {
                req.onsuccess = () => resolve(req.result);
                req.onerror = () => reject(req.error);
            });
        },
        async set(key, value) {
            await this._withStore('readwrite', store => {
                store.put(value, key);
            });
        },
        async delete(key) {
            await this._withStore('readwrite', store => {
                store.delete(key);
            });
        }
    };

    class NostrChatApp {
        constructor() {
            this.state = {
                identity: {sk: null, pubKey: null, profile: null}, // sk is Uint8Array
                relays: ['wss://relay.damus.io', 'wss://relay.nostr.band', 'wss://nos.lol', 'wss://relay.snort.social'],
                pool: null,
                channels: {},
                messages: {},
                profiles: {},
                currentChannelId: null,
                subs: new Map(),
                fetchingProfiles: new Set(),
                messageLimit: 50,
            };
            this.ui = {
                userAvatar: document.getElementById('user-avatar'),
                userName: document.getElementById('user-name'),
                userPubkey: document.getElementById('user-pubkey'),
                identityActionBtn: document.getElementById('identity-action'),
                editProfileBtn: document.getElementById('edit-profile-btn'),
                createGroupBtn: document.getElementById('create-group-btn'),
                joinGroupBtn: document.getElementById('join-group-btn'),
                createDmBtn: document.getElementById('create-dm-btn'),
                channelsList: document.getElementById('channels'),
                chatHeaderName: document.querySelector('#chat-header .channel-name'),
                chatHeaderActions: document.getElementById('chat-header-actions'),
                groupInfoActionBtn: document.getElementById('group-info-action-btn'),
                leaveChannelActionBtn: document.getElementById('leave-channel-action-btn'),
                chatMessages: document.getElementById('chat-messages'),
                chatInputArea: document.getElementById('chat-input'),
                messageForm: document.getElementById('message-form'),
                messageInput: document.getElementById('message-input'),
                loadingIndicator: document.getElementById('loading-indicator'),
                modals: {
                    identity: document.getElementById('identity-modal'),
                    profile: document.getElementById('profile-modal'),
                    createGroup: document.getElementById('create-group-modal'),
                    joinGroup: document.getElementById('join-group-modal'),
                    createDm: document.getElementById('create-dm-modal'),
                    groupInfo: document.getElementById('group-info-modal'),
                },
            };
            this.init();
        }

        async init() {
            this.showLoading(true);
            this.setupEventListeners();
            await this.loadIdentity();
            await this.loadChannels();
            await this.loadProfiles();

            if (this.state.identity.sk && this.state.identity.pubKey) {
                this.initNostrPool();
                this.subscribeToCoreEvents();
                this.ui.identityActionBtn.textContent = 'Logout';
                this.updateSidebarButtonsState(true);
            } else {
                this.renderIdentity();
                this.renderChannels();
                this.updateSidebarButtonsState(false);
            }
            this.selectChannel(this.state.currentChannelId);
            this.initServiceWorker();
            this.showLoading(false);
        }

        updateSidebarButtonsState(loggedIn) {
            this.ui.editProfileBtn.disabled = this.ui.createGroupBtn.disabled = this.ui.joinGroupBtn.disabled = this.ui.createDmBtn.disabled = !loggedIn;
        }

        // --- Key Conversion Utils ---
        uint8ArrayToHex(uint8Array) {
            return Array.from(uint8Array).map(b => b.toString(16).padStart(2, '0')).join('');
        }

        hexToUint8Array(hexString) {
            if (hexString.length % 2 !== 0) throw new Error("Invalid hexString");
            const byteArray = new Uint8Array(hexString.length / 2);
            for (let i = 0; i < byteArray.length; i++) {
                byteArray[i] = parseInt(hexString.substr(i * 2, 2), 16);
            }
            return byteArray;
        }

        getSkHex() {
            return this.state.identity.sk ? this.uint8ArrayToHex(this.state.identity.sk) : null;
        }

        // --- Identity & Profile ---
        async loadIdentity() {
            const idData = await IdbKeyVal.get('identity');
            if (idData && idData.privKeyHex) {
                try {
                    this.state.identity.sk = this.hexToUint8Array(idData.privKeyHex);
                    this.state.identity.pubKey = getPublicKey(this.state.identity.sk);
                    await this.fetchProfile(this.state.identity.pubKey, true);
                } catch (e) {
                    console.error("Failed to load identity from stored hex:", e);
                    this.state.identity = {sk: null, pubKey: null, profile: null};
                    await IdbKeyVal.delete('identity');
                }
            }
            this.renderIdentity();
        }

        async saveIdentity(skInput) {
            let skHex;
            try {
                if (skInput.startsWith('nsec')) {
                    const decoded = nip19.decode(skInput);
                    if (decoded.type !== 'nsec') throw new Error('Invalid nsec key.');
                    skHex = decoded.data;
                } else if (/^[0-9a-fA-F]{64}$/.test(skInput)) {
                    skHex = skInput;
                } else {
                    throw new Error('Invalid secret key format. Use nsec or 64-char hex.');
                }

                this.state.identity.sk = this.hexToUint8Array(skHex);
                this.state.identity.pubKey = getPublicKey(this.state.identity.sk);

                await IdbKeyVal.set('identity', {privKeyHex: skHex});
                await this.fetchProfile(this.state.identity.pubKey, true);
                this.renderIdentity();
                this.ui.identityActionBtn.textContent = 'Logout';
                this.updateSidebarButtonsState(true);
                this.showToast('Identity saved!', 'success');
                return true;
            } catch (e) {
                this.showToast(`Error saving identity: ${e.message}`, 'error');
                console.error('Error saving identity:', e);
                this.state.identity = {sk: null, pubKey: null, profile: null};
                this.renderIdentity();
                this.updateSidebarButtonsState(false);
                return false;
            }
        }

        async createNewIdentity() {
            const skUint8Array = generateSecretKey();
            const skHex = this.uint8ArrayToHex(skUint8Array);
            await this.saveIdentity(skHex);
            this.showToast('New identity created and saved!', 'success');
        }

        async logout() {
            if (!confirm('Are you sure you want to logout? Your secret key will be removed from this device.')) return;
            this.state.identity = {sk: null, pubKey: null, profile: null};
            await IdbKeyVal.delete('identity');
            this.renderIdentity();
            this.renderChannels();
            this.selectChannel(null);
            this.unsubscribeAll();
            if (this.state.pool) this.state.pool.close(this.state.relays);
            this.state.pool = null;
            this.ui.identityActionBtn.textContent = 'Load/Create Identity';
            this.updateSidebarButtonsState(false);
            this.showToast('Logged out.', 'info');
        }

        showProfileEditor() {
            const profile = this.state.identity.profile || {};
            document.getElementById('profile-name-input').value = profile.name || '';
            document.getElementById('profile-picture-input').value = profile.picture || '';
            document.getElementById('profile-nip05-input').value = profile.nip05 || '';
            this.toggleModal('profile', true);
        }

        async updateProfile() {
            if (!this.state.identity.sk) {
                this.showToast('You must be logged in to update your profile.', 'error');
                return;
            }
            this.showLoading(true);
            this.toggleModal('profile', false);

            try {
                const existingEvent = await this.state.pool.get(this.state.relays, {
                    kinds: [0], authors: [this.state.identity.pubKey], limit: 1
                });
                const currentContent = existingEvent ? JSON.parse(existingEvent.content) : {};

                const newContent = {
                    ...currentContent,
                    name: document.getElementById('profile-name-input').value.trim(),
                    picture: document.getElementById('profile-picture-input').value.trim(),
                    nip05: document.getElementById('profile-nip05-input').value.trim(),
                };

                const eventTemplate = {
                    kind: 0,
                    created_at: Math.floor(Date.now() / 1000),
                    tags: [],
                    content: JSON.stringify(newContent),
                };

                const event = await this.publishEvent(eventTemplate);
                await this.parseAndStoreProfile(event);
                this.state.identity.profile = this.state.profiles[this.state.identity.pubKey];
                this.renderIdentity();
                this.renderChannels();
                this.showToast('Profile updated successfully!', 'success');

            } catch (e) {
                console.error('Failed to update profile:', e);
                this.showToast(`Profile update failed: ${e.message}`, 'error');
            } finally {
                this.showLoading(false);
            }
        }

        // --- Nostr & Relays ---
        initNostrPool() {
            if (this.state.pool) {
                this.unsubscribeAll();
                this.state.pool.close(this.state.relays);
            }
            this.state.pool = new SimplePool({eoseSubTimeout: 6000});
        }

        unsubscribeAll() {
            this.state.subs.forEach(sub => sub.unsub());
            this.state.subs.clear();
        }

        manageSubscription(id, relays, filters) {
            if (this.state.subs.has(id)) {
                this.state.subs.get(id).unsub();
            }
            if (!this.state.pool) return null;

            const sub = this.state.pool.subscribe(relays, filters, {
                onevent: (event, relayUrl) => {
                    if (id === 'publicSub') this.handleIncomingEvent(event, 'public');
                    else if (id === 'dmSub' || id === 'groupSub' || id === 'profileSub') this.handleIncomingEvent(event);
                },
            });
            this.state.subs.set(id, sub);
            return sub;
        }

        async publishEvent(eventTemplate) {
            if (!this.state.identity.sk) throw new Error('No secret key available.');
            const event = finalizeEvent(eventTemplate, this.state.identity.sk);

            try {
                await Promise.any(this.state.pool.publish(this.state.relays, event));
                return event;
            } catch (e) {
                console.error("Failed to publish event to any relay:", e);
                this.showToast('Failed to publish event. Check relays.', 'error');
                throw e;
            }
        }

        subscribeToCoreEvents() {
            if (!this.state.pool || !this.state.identity.pubKey) return;
            this.manageSubscription('publicSub', this.state.relays, [{kinds: [1], limit: this.state.messageLimit}]);
            this.manageSubscription('dmSub', this.state.relays, [{
                kinds: [4],
                '#p': [this.state.identity.pubKey],
                limit: this.state.messageLimit
            }]);
            this.manageSubscription('profileSub', this.state.relays, [{
                kinds: [0],
                authors: [this.state.identity.pubKey],
                limit: 1
            }]);
            this.resubscribeToGroups();
        }

        resubscribeToGroups() {
            if (this.state.subs.has('groupSub')) {
                this.state.subs.get('groupSub').unsub();
                this.state.subs.delete('groupSub');
            }
            const groupIds = Object.values(this.state.channels).filter(c => c.type === 'group' && c.id).map(c => c.id);
            if (groupIds.length > 0 && this.state.pool) {
                this.manageSubscription('groupSub', this.state.relays, [{
                    kinds: [1],
                    '#g': groupIds,
                    limit: this.state.messageLimit * groupIds.length
                }]);
            }
        }

        async handleIncomingEvent(event, explicitChannelId = null) {
            let channelId = explicitChannelId;
            let content = event.content;
            let isUnread = true;

            if (event.kind === 0) {
                await this.parseAndStoreProfile(event);
                if (event.pubkey === this.state.identity.pubKey) {
                    this.state.identity.profile = this.state.profiles[event.pubkey];
                    this.renderIdentity();
                }
                this.renderChannels();
                await this.renderMessagesForCurrentChannel();
                return;
            }

            const skHex = this.getSkHex();
            if (event.kind === 4 && skHex) {
                const otherUser = event.pubkey === this.state.identity.pubKey ? event.tags.find(t => t[0] === 'p')?.[1] : event.pubkey;
                if (!otherUser) return;
                channelId = otherUser;
                try {
                    content = await nip04.decrypt(skHex, otherUser, event.content);
                    if (!this.state.channels[channelId]) {
                        this.state.channels[channelId] = {
                            id: channelId,
                            name: this.shortenPubkey(channelId),
                            type: 'dm',
                            pubkey: channelId,
                            unread: 0
                        };
                        await this.saveChannels();
                        await this.fetchProfile(channelId);
                        this.renderChannels();
                    }
                } catch (e) {
                    console.warn('Failed to decrypt DM:', e);
                    return;
                }
            } else if (event.kind === 1) {
                const groupTag = event.tags.find(t => t[0] === '#g');
                if (groupTag && groupTag[1]) {
                    channelId = groupTag[1];
                    const group = this.state.channels[channelId];
                    if (!group || group.type !== 'group' || !group.secretKey) return;
                    try {
                        content = await this.aesDecrypt(event.content, group.secretKey);
                    } catch (e) {
                        console.warn(`Failed to decrypt group message for ${channelId}:`, e);
                        return;
                    }
                } else if (!explicitChannelId) {
                    channelId = 'public';
                }
            } else {
                return;
            }

            if (!channelId) return;
            const processedEvent = {...event, content, decrypted: true};
            if (!this.state.messages[channelId]) this.state.messages[channelId] = [];
            if (this.state.messages[channelId].find(m => m.id === event.id)) return;

            this.state.messages[channelId].push(processedEvent);
            this.state.messages[channelId].sort((a, b) => a.created_at - b.created_at);
            if (this.state.messages[channelId].length > this.state.messageLimit) {
                this.state.messages[channelId] = this.state.messages[channelId].slice(-this.state.messageLimit);
            }
            await this.saveMessages(channelId);

            if (channelId === this.state.currentChannelId) {
                this.renderMessageItem(processedEvent, true);
                this.scrollToBottom();
                isUnread = false;
            }

            if (isUnread && event.pubkey !== this.state.identity.pubKey) {
                if (this.state.channels[channelId]) {
                    this.state.channels[channelId].unread = (this.state.channels[channelId].unread || 0) + 1;
                }
            }
            if (this.state.channels[channelId]) {
                this.state.channels[channelId].lastEventTimestamp = event.created_at;
            }
            this.renderChannels();
            await this.fetchProfile(event.pubkey);
        }

        // --- Channels ---
        async loadChannels() {
            const storedChannels = await IdbKeyVal.get('channels');
            if (storedChannels) this.state.channels = storedChannels;
            if (!this.state.channels.public) {
                this.state.channels.public = {
                    id: 'public',
                    name: 'Public Channel',
                    type: 'public',
                    unread: 0,
                    lastEventTimestamp: 0
                };
            }
            for (const chId in this.state.channels) {
                if (!this.state.channels[chId].lastEventTimestamp) this.state.channels[chId].lastEventTimestamp = 0;
            }
            this.renderChannels();
        }

        async saveChannels() {
            await IdbKeyVal.set('channels', this.state.channels);
        }

        selectChannel(channelId) {
            if (!channelId) channelId = 'public';

            const channel = this.state.channels[channelId];

            if (!channel) {
                if (channelId !== 'public') {
                    this.showToast(`Channel ${channelId} not found. Selecting Public.`, 'warn');
                    this.selectChannel('public');
                } else {
                    this.state.currentChannelId = null;
                    this.ui.chatHeaderName.textContent = 'Select a channel';
                    this.ui.chatMessages.innerHTML = '<div class="message system"><div class="message-content">Welcome! Please select a channel, or create/load an identity to get started.</div></div>';
                    this.ui.chatInputArea.classList.add('hidden');
                    this.ui.groupInfoActionBtn.classList.add('hidden');
                    this.ui.leaveChannelActionBtn.classList.add('hidden');
                    this.renderChannels();
                }
                return;
            }

            this.state.currentChannelId = channelId;
            this.ui.chatHeaderName.textContent = channel.name;
            this.ui.chatInputArea.classList.toggle('hidden', !this.state.identity.sk);

            this.ui.groupInfoActionBtn.classList.add('hidden');
            this.ui.leaveChannelActionBtn.classList.add('hidden');
            this.ui.groupInfoActionBtn.onclick = null;
            this.ui.leaveChannelActionBtn.onclick = null;

            if (channel.type === 'group') {
                this.ui.groupInfoActionBtn.classList.remove('hidden');
                this.ui.groupInfoActionBtn.onclick = () => this.showGroupInfoModal(channel.id, channel.secretKey, channel.name);
                this.ui.leaveChannelActionBtn.classList.remove('hidden');
                this.ui.leaveChannelActionBtn.textContent = 'Leave Group';
                this.ui.leaveChannelActionBtn.onclick = () => this.leaveChannel(channel.id);
            } else if (channel.type === 'dm') {
                this.ui.leaveChannelActionBtn.classList.remove('hidden');
                this.ui.leaveChannelActionBtn.textContent = 'Hide Chat';
                this.ui.leaveChannelActionBtn.onclick = () => this.leaveChannel(channel.id);
            }

            if (channel.unread > 0) {
                channel.unread = 0;
                this.saveChannels();
            }

            this.renderChannels();
            this.renderMessagesForCurrentChannel();
        }

        async leaveChannel(channelId) {
            const channel = this.state.channels[channelId];
            if (!channel) return;

            const confirmationText = channel.type === 'group'
                ? `Are you sure you want to leave the group "${channel.name}"? This cannot be undone.`
                : `Are you sure you want to hide the chat with "${channel.name}"? You can re-add them later.`;

            if (!confirm(confirmationText)) return;

            delete this.state.channels[channelId];
            delete this.state.messages[channelId];
            await IdbKeyVal.delete(`messages_${channelId}`);
            await this.saveChannels();

            if (channel.type === 'group') this.resubscribeToGroups();

            this.selectChannel('public');
            this.renderChannels();
            this.showToast(`Channel "${channel.name}" has been removed.`, 'info');
        }

        async createDmChannel(pubkeyInput) {
            let pk;
            try {
                if (pubkeyInput.startsWith('npub')) {
                    pk = nip19.decode(pubkeyInput).data;
                } else if (/^[0-9a-fA-F]{64}$/.test(pubkeyInput)) {
                    pk = pubkeyInput;
                } else {
                    throw new Error('Invalid public key format.');
                }
                if (pk === this.state.identity.pubKey) throw new Error("Cannot create DM with yourself.");
            } catch (e) {
                this.showToast(`Error: ${e.message}`, 'error');
                return;
            }

            if (!this.state.channels[pk]) {
                this.state.channels[pk] = {
                    id: pk,
                    name: this.shortenPubkey(pk),
                    type: 'dm',
                    pubkey: pk,
                    unread: 0,
                    lastEventTimestamp: Math.floor(Date.now() / 1000)
                };
                await this.saveChannels();
                await this.fetchProfile(pk);
                this.renderChannels();
            }
            this.selectChannel(pk);
            this.showToast(`DM with ${this.state.channels[pk].name} started.`, 'success');
        }

        async createEncryptedGroupChannel(name) {
            if (!name.trim()) {
                this.showToast('Group name cannot be empty.', 'error');
                return;
            }
            const groupId = this.generateUUID();
            const rawKey = await crypto.subtle.generateKey({
                name: "AES-GCM",
                length: 256
            }, true, ["encrypt", "decrypt"]);
            const secretKey = await this.exportKeyAsBase64(rawKey);

            this.state.channels[groupId] = {
                id: groupId,
                name,
                type: 'group',
                secretKey,
                unread: 0,
                creator: this.state.identity.pubKey,
                lastEventTimestamp: Math.floor(Date.now() / 1000)
            };
            await this.saveChannels();
            this.resubscribeToGroups();
            this.renderChannels();
            this.selectChannel(groupId);
            this.showToast(`Encrypted group "${name}" created.`, 'success');
            this.showGroupInfoModal(groupId, secretKey, name);
        }

        async joinEncryptedGroupChannel(groupId, secretKey, name) {
            if (!name.trim()) {
                this.showToast('Group name cannot be empty.', 'error');
                return;
            }
            if (this.state.channels[groupId]) {
                this.showToast(`You are already in group: ${this.state.channels[groupId].name}`, 'warn');
                this.selectChannel(groupId);
                return;
            }
            try {
                atob(secretKey);
            } catch (e) {
                this.showToast('Invalid secret key format. Must be Base64.', 'error');
                return;
            }

            this.state.channels[groupId] = {
                id: groupId,
                name,
                type: 'group',
                secretKey,
                unread: 0,
                lastEventTimestamp: Math.floor(Date.now() / 1000)
            };
            await this.saveChannels();
            this.resubscribeToGroups();
            this.renderChannels();
            this.selectChannel(groupId);
            this.showToast(`Joined encrypted group "${name}".`, 'success');
        }

        showGroupInfoModal(groupId, secretKey, groupName) {
            document.getElementById('group-info-name').textContent = `Info for "${groupName}"`;
            document.getElementById('group-info-id').value = groupId;
            document.getElementById('group-info-key').value = secretKey;
            this.toggleModal('groupInfo', true);
        }

        // --- Messages ---
        async loadMessages(channelId) {
            if (!channelId) return;
            const storedMessages = await IdbKeyVal.get(`messages_${channelId}`);
            this.state.messages[channelId] = storedMessages || [];
        }

        async saveMessages(channelId) {
            if (!channelId || !this.state.messages[channelId]) return;
            await IdbKeyVal.set(`messages_${channelId}`, this.state.messages[channelId]);
        }

        async sendMessage() {
            const content = this.ui.messageInput.value.trim();
            if (!content || !this.state.currentChannelId || !this.state.identity.sk) return;

            this.showLoading(true);
            const channel = this.state.channels[this.state.currentChannelId];
            let eventTemplate = {
                kind: 1, created_at: Math.floor(Date.now() / 1000), tags: [], content: content,
            };

            try {
                const skHex = this.getSkHex();
                if (channel.type === 'dm') {
                    eventTemplate.kind = 4;
                    eventTemplate.tags.push(['p', channel.pubkey]);
                    eventTemplate.content = await nip04.encrypt(skHex, channel.pubkey, content);
                } else if (channel.type === 'group') {
                    eventTemplate.tags.push(['#g', channel.id]);
                    eventTemplate.content = await this.aesEncrypt(content, channel.secretKey);
                }

                const event = await this.publishEvent(eventTemplate);
                await this.handleIncomingEvent({
                    ...event,
                    content: content,
                    decrypted: true
                }, this.state.currentChannelId);
                this.ui.messageInput.value = '';
            } catch (e) {
                console.error("Send message error:", e);
            } finally {
                this.showLoading(false);
            }
        }

        // --- Profiles (Kind 0) ---
        async loadProfiles() {
            const storedProfiles = await IdbKeyVal.get('profiles');
            if (storedProfiles) this.state.profiles = storedProfiles;
        }

        async saveProfiles() {
            await IdbKeyVal.set('profiles', this.state.profiles);
        }

        async fetchProfile(pubkey, isSelf = false) {
            if (!pubkey || this.state.profiles[pubkey]?.name || this.state.fetchingProfiles.has(pubkey) || !this.state.pool) return;
            this.state.fetchingProfiles.add(pubkey);
            try {
                const event = await this.state.pool.get(this.state.relays, {kinds: [0], authors: [pubkey], limit: 1});
                if (event) {
                    await this.parseAndStoreProfile(event);
                    if (isSelf && this.state.profiles[pubkey]) {
                        this.state.identity.profile = this.state.profiles[pubkey];
                        this.renderIdentity();
                    }
                    this.renderChannels();
                    await this.renderMessagesForCurrentChannel();
                }
            } catch (e) {
                console.warn(`Error fetching profile for ${pubkey}:`, e);
            } finally {
                this.state.fetchingProfiles.delete(pubkey);
            }
        }

        async parseAndStoreProfile(event) {
            if (event.kind !== 0) return;
            try {
                const profileData = JSON.parse(event.content);
                const newProfile = {
                    name: profileData.name || profileData.display_name || this.shortenPubkey(event.pubkey),
                    picture: profileData.picture,
                    nip05: profileData.nip05,
                    pubkey: event.pubkey,
                    lastUpdatedAt: event.created_at,
                };
                const existing = this.state.profiles[event.pubkey];
                if (!existing || newProfile.lastUpdatedAt > (existing.lastUpdatedAt || 0)) {
                    this.state.profiles[event.pubkey] = newProfile;
                    await this.saveProfiles();
                }
            } catch (e) {
                console.warn('Error parsing profile event content:', e);
            }
        }

        // --- UI Rendering ---
        renderIdentity() {
            const {pubKey, profile} = this.state.identity;
            if (pubKey) {
                const displayName = profile?.name || this.shortenPubkey(pubKey);
                this.ui.userName.textContent = displayName;
                try {
                    this.ui.userPubkey.textContent = nip19.npubEncode(pubKey);
                } catch {
                    this.ui.userPubkey.textContent = this.shortenPubkey(pubKey);
                }
                this.ui.userAvatar.src = profile?.picture || this.generateAvatarSvg(displayName.charAt(0).toUpperCase(), this.getUserColor(pubKey));
                this.ui.userAvatar.onerror = () => {
                    this.ui.userAvatar.src = this.generateAvatarSvg(displayName.charAt(0).toUpperCase(), this.getUserColor(pubKey));
                };
            } else {
                this.ui.userName.textContent = 'Anonymous';
                this.ui.userPubkey.textContent = 'No identity loaded';
                this.ui.userAvatar.src = this.generateAvatarSvg('?', '#ccc');
            }
        }

        renderChannels() {
            this.ui.channelsList.innerHTML = '';
            const sortedChannels = Object.values(this.state.channels).sort((a, b) => (b.lastEventTimestamp || 0) - (a.lastEventTimestamp || 0));

            for (const channel of sortedChannels) {
                if (!channel || !channel.id) continue;
                if ((channel.type === 'dm' || channel.type === 'group') && !this.state.identity.sk) continue;

                const el = document.createElement('div');
                el.className = `channel ${channel.id === this.state.currentChannelId ? 'active' : ''}`;
                el.dataset.channelId = channel.id;

                let icon = '‚ùì', meta = '', channelDisplayName = channel.name;
                if (channel.type === 'public') {
                    icon = 'üåê';
                    meta = `${this.state.relays.length} relays`;
                } else if (channel.type === 'dm') {
                    icon = 'üë§';
                    const contactProfile = this.state.profiles[channel.pubkey];
                    channelDisplayName = contactProfile?.name || channel.name;
                    meta = 'Direct Message';
                } else if (channel.type === 'group') {
                    icon = 'üë•';
                    meta = 'Encrypted Group';
                }

                el.innerHTML = `<div class="channel-icon">${icon}</div>
                <div class="channel-details">
                    <div class="channel-name">
                        <span>${this.escapeHtml(channelDisplayName)}</span>
                        ${channel.unread > 0 ? `<span class="channel-unread">${channel.unread}</span>` : ''}
                    </div>
                    <div class="channel-meta">${this.escapeHtml(meta)}</div>
                </div>`;
                el.addEventListener('click', () => this.selectChannel(channel.id));
                this.ui.channelsList.appendChild(el);
            }
        }

        async renderMessagesForCurrentChannel() {
            this.ui.chatMessages.innerHTML = '';
            const channelId = this.state.currentChannelId;
            if (!channelId) return;

            await this.loadMessages(channelId);
            const messages = this.state.messages[channelId] || [];
            if (messages.length === 0 && channelId === 'public') this.renderSystemMessage("Welcome to the Public channel! Messages here are from Nostr's global feed (Kind 1).");
            else if (messages.length === 0) this.renderSystemMessage("No messages yet in this channel.");

            messages.forEach(msg => this.renderMessageItem(msg, false));
            this.scrollToBottom();
        }

        renderMessageItem(msg, append = true) {
            const isSelf = msg.pubkey === this.state.identity.pubKey;
            const profile = this.state.profiles[msg.pubkey] || {
                name: this.shortenPubkey(msg.pubkey),
                pubkey: msg.pubkey
            };
            const senderName = isSelf ? 'You' : profile.name;
            const el = document.createElement('div');
            el.className = `message ${isSelf ? 'self' : ''}`;
            el.dataset.messageId = msg.id;
            const avatarSrc = profile.picture || this.generateAvatarSvg(senderName.charAt(0).toUpperCase(), this.getUserColor(msg.pubkey));
            el.innerHTML = `<div class="message-avatar"><img class="avatar" src="${avatarSrc}" alt="${senderName.charAt(0)}" onerror="this.src='${this.generateAvatarSvg(senderName.charAt(0).toUpperCase(), this.getUserColor(msg.pubkey))}';"></div>
            <div class="message-content"><div class="message-header"><div class="message-sender">${this.escapeHtml(senderName)}</div><div class="message-time">${this.formatTime(msg.created_at * 1000)}</div></div><div class="message-text">${this.escapeHtml(msg.content)}</div></div>`;
            if (append) this.ui.chatMessages.appendChild(el);
            else this.ui.chatMessages.appendChild(el);
        }

        renderSystemMessage(text) {
            const el = document.createElement('div');
            el.className = 'message system';
            el.innerHTML = `<div class="message-content"><div class="message-text">${this.escapeHtml(text)}</div></div>`;
            this.ui.chatMessages.appendChild(el);
        }

        scrollToBottom() {
            this.ui.chatMessages.scrollTop = this.ui.chatMessages.scrollHeight;
        }

        // --- UI Helpers & Event Listeners ---
        setupEventListeners() {
            this.ui.identityActionBtn.addEventListener('click', () => {
                if (this.state.identity.sk) this.logout(); else this.toggleModal('identity', true);
            });
            document.getElementById('identity-modal-cancel').addEventListener('click', () => this.toggleModal('identity', false));
            document.getElementById('identity-modal-save').addEventListener('click', async () => {
                const pkInput = document.getElementById('privkey-input').value.trim();
                this.showLoading(true);
                let success = false;
                if (pkInput) success = await this.saveIdentity(pkInput);
                else {
                    await this.createNewIdentity();
                    success = true;
                }
                this.toggleModal('identity', false);
                document.getElementById('privkey-input').value = '';
                if (success && this.state.identity.sk) {
                    this.initNostrPool();
                    this.subscribeToCoreEvents();
                    this.selectChannel(this.state.currentChannelId || 'public');
                }
                this.showLoading(false);
            });

            this.ui.editProfileBtn.addEventListener('click', () => this.showProfileEditor());
            document.getElementById('profile-modal-cancel').addEventListener('click', () => this.toggleModal('profile', false));
            document.getElementById('profile-modal-save').addEventListener('click', () => this.updateProfile());

            this.ui.createGroupBtn.addEventListener('click', () => this.toggleModal('createGroup', true));
            document.getElementById('create-group-modal-cancel').addEventListener('click', () => this.toggleModal('createGroup', false));
            document.getElementById('create-group-modal-create').addEventListener('click', async () => {
                const name = document.getElementById('group-name-input').value.trim();
                await this.createEncryptedGroupChannel(name);
                this.toggleModal('createGroup', false);
                document.getElementById('group-name-input').value = '';
            });

            this.ui.joinGroupBtn.addEventListener('click', () => this.toggleModal('joinGroup', true));
            document.getElementById('join-group-modal-cancel').addEventListener('click', () => this.toggleModal('joinGroup', false));
            document.getElementById('join-group-modal-join').addEventListener('click', async () => {
                const id = document.getElementById('join-group-id-input').value.trim();
                const key = document.getElementById('join-group-key-input').value.trim();
                const name = document.getElementById('join-group-name-input').value.trim();
                if (id && key && name) {
                    await this.joinEncryptedGroupChannel(id, key, name);
                    this.toggleModal('joinGroup', false);
                    ['join-group-id-input', 'join-group-key-input', 'join-group-name-input'].forEach(elId => document.getElementById(elId).value = '');
                } else this.showToast('All fields are required.', 'error');
            });

            this.ui.createDmBtn.addEventListener('click', () => this.toggleModal('createDm', true));
            document.getElementById('create-dm-modal-cancel').addEventListener('click', () => this.toggleModal('createDm', false));
            document.getElementById('create-dm-modal-start').addEventListener('click', async () => {
                const pubkey = document.getElementById('dm-pubkey-input').value.trim();
                if (pubkey) {
                    await this.createDmChannel(pubkey);
                    this.toggleModal('createDm', false);
                    document.getElementById('dm-pubkey-input').value = '';
                } else this.showToast('Recipient public key is required.', 'error');
            });

            document.getElementById('group-info-close').addEventListener('click', () => this.toggleModal('groupInfo', false));
            this.ui.messageForm.addEventListener('submit', e => {
                e.preventDefault();
                this.sendMessage();
            });
            this.ui.messageInput.addEventListener('keypress', e => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    this.sendMessage();
                }
            });
        }

        toggleModal(modalName, show) {
            if (this.ui.modals[modalName]) this.ui.modals[modalName].classList.toggle('hidden', !show);
        }

        showToast(message, type = 'info') {
            const existingToast = document.querySelector('.toast');
            if (existingToast) existingToast.remove();
            const toast = document.createElement('div');
            toast.className = 'toast';
            toast.textContent = message;
            let bgColor = 'var(--header-bg)';
            if (type === 'error') bgColor = 'var(--danger)';
            else if (type === 'success') bgColor = 'var(--success)';
            toast.style.background = bgColor;
            document.body.appendChild(toast);
            setTimeout(() => {
                toast.style.opacity = '0';
                setTimeout(() => toast.remove(), 300);
            }, 3000);
        }

        showLoading(isLoading) {
            this.ui.loadingIndicator.style.display = isLoading ? 'block' : 'none';
        }

        // --- Crypto & Utils ---
        async aesEncrypt(text, base64Key) {
            const key = await this.importKeyFromBase64(base64Key);
            const iv = crypto.getRandomValues(new Uint8Array(12));
            const encodedText = new TextEncoder().encode(text);
            const encryptedContent = await crypto.subtle.encrypt({name: "AES-GCM", iv}, key, encodedText);
            return `${this.uint8ArrayToBase64(iv)}:${this.uint8ArrayToBase64(new Uint8Array(encryptedContent))}`;
        }

        async aesDecrypt(data, base64Key) {
            const key = await this.importKeyFromBase64(base64Key);
            const [ivBase64, encryptedBase64] = data.split(':');
            if (!ivBase64 || !encryptedBase64) throw new Error('Invalid encrypted data format');
            const iv = this.base64ToUint8Array(ivBase64);
            const encryptedContent = this.base64ToUint8Array(encryptedBase64);
            const decryptedContent = await crypto.subtle.decrypt({name: "AES-GCM", iv}, key, encryptedContent);
            return new TextDecoder().decode(decryptedContent);
        }

        async exportKeyAsBase64(key) {
            const exported = await crypto.subtle.exportKey("raw", key);
            return this.uint8ArrayToBase64(new Uint8Array(exported));
        }

        async importKeyFromBase64(base64Key) {
            const rawKey = this.base64ToUint8Array(base64Key);
            return crypto.subtle.importKey("raw", rawKey, {name: "AES-GCM"}, true, ["encrypt", "decrypt"]);
        }

        uint8ArrayToBase64(arr) {
            return btoa(String.fromCharCode.apply(null, arr));
        }

        base64ToUint8Array(str) {
            return new Uint8Array(atob(str).split("").map(c => c.charCodeAt(0)));
        }

        generateUUID() {
            return crypto.randomUUID();
        }

        shortenPubkey(pk) {
            return pk ? `${pk.substring(0, 8)}...${pk.substring(pk.length - 4)}` : 'unknown';
        }

        formatTime(timestamp) {
            return new Date(timestamp).toLocaleTimeString([], {hour: '2-digit', minute: '2-digit'});
        }

        escapeHtml(unsafe) {
            if (typeof unsafe !== 'string') return '';
            return unsafe.replace(/&/g, "&").replace(/</g, "<").replace(/>/g, ">").replace(/"/g, "\"").replace(/'/g, "'");
        }

        getUserColor(pubkey) {
            const colors = ['#4dabf7', '#20c997', '#f06595', '#cc5de8', '#5c7cfa', '#fcc419', '#ff8787', '#74b816'];
            if (!pubkey) return colors[0];
            const hash = Array.from(pubkey).reduce((acc, char) => acc + char.charCodeAt(0), 0);
            return colors[hash % colors.length];
        }

        generateAvatarSvg(initial, color) {
            const svg = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><rect width="100" height="100" fill="${this.escapeHtml(color)}"/><text x="50%" y="50%" font-size="50" dominant-baseline="central" text-anchor="middle" fill="white" font-family="system-ui, sans-serif">${this.escapeHtml(initial)}</text></svg>`;
            return `data:image/svg+xml,${encodeURIComponent(svg)}`;
        }

        // --- PWA ---
        initServiceWorker() {
            if ('serviceWorker' in navigator) {
                const swContent = `
                const CACHE_NAME = 'nostr-chat-v2';
                const urlsToCache = ['/'];
                self.addEventListener('install', e => { e.waitUntil(caches.open(CACHE_NAME).then(c => c.addAll(urlsToCache))); self.skipWaiting(); });
                self.addEventListener('activate', e => { e.waitUntil(caches.keys().then(names => Promise.all(names.filter(n => n !== CACHE_NAME).map(n => caches.delete(n))))); self.clients.claim(); });
                self.addEventListener('fetch', e => {
                    if (e.request.mode === 'navigate') { e.respondWith(caches.match('/')); return; }
                    e.respondWith(caches.match(e.request).then(res => res || fetch(e.request)));
                });`;
                const swBlob = new Blob([swContent], {type: 'application/javascript'});
                navigator.serviceWorker.register(URL.createObjectURL(swBlob))
                    .then(reg => console.log('Service worker registered:', reg.scope))
                    .catch(err => console.error('Service worker registration failed:', err));
            }
        }
    }

    document.addEventListener('DOMContentLoaded', () => {
        window.nostrChatApp = new NostrChatApp();
    });

</script>
</body>
</html>